# Kleene Hierarchy
## The Iteration Theorem
$[r]^A_n(x^{(n)})$的含义，$r$是图灵机的歌德尔数  
### Thm 1.1
There is primitive recursive function $\gamma(r,y)$ s,t.
$[r]^A_{n+1}(y,x^{(n)})=[\gamma(r,y)]_n^A(x^{(n)}))$  
#### 证明思路简单
思路
 * 在$x^{(n)}$左边敲上$y$再Z
 * 计算上面这个TM的歌德尔数，这个TM输入$x^{(n)}$，y是参数，对不同y得到的TM不同
 * 上面这个过程就是计算$\gamma(r,y)$的过程

细节
 * $\varphi(y)$ 左边敲$y$补上的四元组
 * $\theta(r,y)$ 原来的四元组平移后
 * $\tau(r)$ $r$是否是图灵机的歌德尔数
 * $\gamma(r,y)=(\varphi(y)*\theta(r,y))\tau(r)$

### Thm 1.2 $S_n^m$
Thm1.1 的多次迭代  
$[r]^A_{m+n}(\eta^{(m)}),x^{(n)})=[S^m(r,\eta^{(m)})]_n^A(x^{(n)})$

#### Discussion
把参数硬编码进 algorithm/code 里

## 应用
### {p}并/交{q}={h(p,q)},h原始递归
也就是说有一个原始递归的方法列举两个 r.e 集合的交/并 直接用推论 1.5 证明
### composition
## Relative to a predicate $P(x^{(n)})$
$P^*=\{x|P(1Glx,...,nGlx)\}$ 谓词和集合的对应 $P^*$ is associated set of $P$   
P与$P^*$显然可互推/等价 可以根据$P^*$判断$x^{(n)}$符不符合P，可以根据P判断x在不在$P^*$里  
这样我们就可以定义相对于谓词可计算（利用相对于集合可计算）  
其实很好理解，相对于集合就是判断在不在集合里，相对于谓词就是是否符合谓词
## Relative to a function $g(x^{(n)})$ g must be total?
令谓词 P<->y==g(x^{(n)})  

## 规约
至此，我们定义了所有要素的相对可计算（集合、函数、谓词）  
$a\prec b$: a is b-computable, a is Turing reducible to b, a is recursively reducible to b, a is reducible to b.  
有了b就可以附加一个图灵过程计算a，b强于或等于a
### $a\prec b$ iff $a^*\prec b^*$
a is b-computable 的定义就是 $a\prec b^*$，因为定义了集合\*=集合本身，而谓词可计算就是在集合可计算基础上定义一个集合=谓词\*来的，函数可计算就是在谓词可计算基础上定义一个谓词=函数\*来的。
### $a\prec a$
### $a\prec b$,$b\prec c$ -> $a\prec c$

## 强规约
a*,b* 是ab的关联集合（谓词的关联集合是外延，函数的关联集合就是(x,y)对）
$a\prec\prec b$ 定义为存在 recursive $f(x)$ s.t. $a^*=\{x|f(x)\in b^*\}$
### $a\prec\prec b$ -> $a\prec b$
因为你可以用一个图灵机，它判断f(x)在不在b*里，从而就可以判断x在不在a里
### $a\prec\prec a$
f(x)=x
### $a\prec\prec b,b\prec\prec c \rightarrow a\prec\prec c$
f(g(x))
### C is A-recursive enumerable iff $C\prec\prec A'$
### 强规约和规约有什么区别？ 

# 个人总结
## 相对集合、函数、谓词可计算
相对集合可计算就是说判断数在不在这个集合里，是可以直接告诉你的图灵机/机器/算法/代码的，你可以认为是额外有一个机器，你去调用它就可以得到结果，不支付任何代价。    
相对谓词可计算其实就是判断一个数是否符合这个谓词是可以直接告诉你的。  
相对函数可计算其实就是判断一对$(x^{(n)},y)$符不符合这个函数是可以直接告诉你的。（函数的本质就是$X\times Y$的子集，所以相对函数可计算的定义就是和相对集合可计算同源的）  
## 什么叫算一个集合/函数/谓词
算一个函数很简单，等于有一个图灵机输入输出和这个函数一样。  
集合可计算，就是它的特征函数可计算，其实就是判断一个数在不在集合里的过程是可以图灵机描述的。  
谓词可计算，判断它的外延集合可计算，其实就是判断一组参数符不符合谓词的过程是可以图灵机描述的。
## 相对可计算/规约
a is b-computable，a 就不强于 b，加深一下理解：
 * 给你有限时间算b的机器（它可能是一个超越图灵机的机器），你就可以用图灵机有限时间算a了，显然这个算b更难一点，算b的机器更高级一点，算b的机器附加一个图灵过程也必然可以算a，这就是规约。
 * b 如果是空集/图灵可计算，那么一个图灵机其实不需要 b 就可以算 a 这个集合/函数/谓词，所以 ab 是等势的。
 * ab 都是集合，判断一个数在不在a集合里，如果a图灵可计算，那么不需要b就可以算，所以相对于任意b，a是可计算的，所以图灵可计算集合是最低势的集合；如果a不可计算，也就是没有图灵机可以在有限时间判断x在不在a里。现在如果预先给定了b，判断一个数在不在b里可以直接无代价/有限时间内告诉你，那么借助b我就有了一个图灵机判断一个数在不在a里，所以可以直观感受到算b的难度不弱于a。
 * ab都是函数，判断(x,y)在不在a里，如果一个图灵机不行，有了b就能算了，这个其实和集合挺像的，因为函数其实就是集合。
 * ab都是谓词，判断x符不符合a，如果一个图灵机不行，给你有限时间判断x符不符合b的超越机器就能算了，所以算b的难度不下于a。
 * 像上面这种理解可以写9种，其实一种就够了，写着玩而已。

## 强规约到底是啥？
好像不是等势，也不是不等势，到底是什么阿！！！  
维基百科说，此处的强规约叫做one-one reduction，只需一次测试某个y在不在b里的就可以完成x在不在a里的测试，弱规约允许无数次。确实如此，很有道理。上方定义中，要测试x在不在a里，只需测f(x)在不在b里。但是还不够直观。